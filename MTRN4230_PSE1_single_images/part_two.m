function part_two
chocolate1 = imread('IMG_0014.jpg');
chocolate2 = imread('IMG_0017.jpg');
chocolate1 = imrotate(chocolate1,180);
chocolate2 = imrotate(chocolate2,180);

%isolate bench
chocolate1_ = isolate(chocolate1);
figure();
chocolate2_ = isolate(chocolate2);
Chocolate = chocolate1_;%input Image
[BWchoco1,maskedChoco1]  = createMask(Chocolate);
imshow(BWchoco1);
BWchoco1 = bwareaopen(BWchoco1, 120);
CH = bwconvhull(BWchoco1); figure();imshow(CH);
centroidChoco1 = regionprops(CH, 'Centroid');
orientation = regionprops(CH,'Orientation');
[p1 p2 p3 p4 p5 p6] = getGlobalPoints(orientation.Orientation,centroidChoco1.Centroid,[80 170]);
p1 = int16(p1); p2 = int16(p2);p3 = int16(p3); p4 = int16(p4);p5 = int16(p5); p6 = int16(p6);
BWregion1 = roipoly(BWchoco1,[p1(1),p2(1),p5(1),p6(1)],[p1(2),p2(2),p5(2),p6(2)]); 
BWregion2 = roipoly(BWchoco1,[p3(1),p4(1),p5(1),p6(1)],[p3(2),p4(2),p5(2),p6(2)]); 
region1 = BWregion1.*(BWchoco1);
region2 = BWregion2.*(BWchoco1);
if size(find(region1==1)) > size(find(region2==1))
    heading = 1;
else
    heading = 2;
end
for increment = 0:1:200
lineLength = sqrt((increment*tan(orientation.Orientation*pi/180))^2+(increment)^2);
    if lineLength > 100
    break
    end
end
figure(1); imshow(chocolate1);hold on;
if heading == 1
    line1 = line([centroidChoco1.Centroid(1) centroidChoco1.Centroid(1)+increment],[centroidChoco1.Centroid(2) centroidChoco1.Centroid(2)-increment*tan(orientation.Orientation*pi/180)],'color','r','LineWidth',4);
else
    line1 = line([centroidChoco1.Centroid(1) centroidChoco1.Centroid(1)-increment],[centroidChoco1.Centroid(2) centroidChoco1.Centroid(2)+increment*tan(orientation.Orientation*pi/180)],'color','r','LineWidth',4);
end
line2 = line([centroidChoco1.Centroid(1) centroidChoco1.Centroid(1)+100],[centroidChoco1.Centroid(2) centroidChoco1.Centroid(2)],'color','r','LineWidth',4);
hold off
end




function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder App. The colorspace and
%  minimum/maximum values for each channel of the colorspace were set in the
%  App and result in a binary mask BW and a composite image maskedRGBImage,
%  which shows the original RGB image values under the mask BW.

% Auto-generated by colorThresholder app on 28-Mar-2015
%------------------------------------------------------


% Convert RGB image to chosen color space
I = RGB;

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.000;
channel1Max = 158.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 206.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 57.000;
channel3Max = 255.000;

% Create mask based on chosen histogram thresholds
BW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
end

function result = isolate(bench)
    xx = [1 1600 1600 1]; yy = [963 963 1200 1200];
    result = icolor(uint8(imcomplement(roipoly(bench,xx,yy)))).*bench;
    return
end

function [point1Global,point2Global,point3Global,point4Global,point5Global,point6Global] = getGlobalPoints(orientation,centriod,objectDimension)
    theta = (orientation)*pi/180;
    L = objectDimension(2)/2; W = objectDimension(1)/2;
    point1 = [L -W];
    point2 = [L W];
    point3 = [-L -W];
    point4 = [-L W];
    point5 = [0 W];
    point6 = [0 -W];
    point1Global = [centriod(1)-point1(1)*cos(theta)-sin(theta)*point1(2) centriod(2)+point1(1)*sin(theta)-cos(theta)*point1(2)];
    point2Global = [centriod(1)-point2(1)*cos(theta)-sin(theta)*point2(2) centriod(2)+point2(1)*sin(theta)-cos(theta)*point2(2)];
    point3Global = [centriod(1)-point3(1)*cos(theta)-sin(theta)*point3(2) centriod(2)+point3(1)*sin(theta)-cos(theta)*point3(2)];
    point4Global = [centriod(1)-point4(1)*cos(theta)-sin(theta)*point4(2) centriod(2)+point4(1)*sin(theta)-cos(theta)*point4(2)];
    point5Global = [centriod(1)-point5(1)*cos(theta)-sin(theta)*point5(2) centriod(2)+point5(1)*sin(theta)-cos(theta)*point5(2)];
    point6Global = [centriod(1)-point6(1)*cos(theta)-sin(theta)*point6(2) centriod(2)+point6(1)*sin(theta)-cos(theta)*point6(2)];
    return
end
